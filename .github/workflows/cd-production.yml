name: CD - Deploy to Production

# Trigger only on version tags (v*.*.*)
on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch: # Allow manual production deployment
    inputs:
      version:
        description: 'Version tag to deploy (e.g., v1.0.0)'
        required: true
        type: string
      confirm:
        description: 'Type "DEPLOY" to confirm production deployment'
        required: true
        type: string

# Environment variables
env:
  HELM_VERSION: 'v3.13.3'
  KUBECTL_VERSION: 'v1.28.0'
  REGISTRY: ghcr.io

# Set permissions
permissions:
  contents: read
  packages: read
  id-token: write # For OIDC authentication

jobs:
  # Pre-deployment checks
  pre-deployment-checks:
    name: Pre-Deployment Validation
    runs-on: ubuntu-22.04
    outputs:
      version: ${{ steps.get-version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0 # Fetch all history for tag verification

      - name: Validate manual deployment confirmation
        if: github.event_name == 'workflow_dispatch'
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "DEPLOY" ]; then
            echo "ERROR: Production deployment not confirmed. You must type 'DEPLOY' to proceed."
            exit 1
          fi

      - name: Get version from tag or input
        id: get-version
        run: |
          if [ "${{ github.event_name }}" == "push" ]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=${{ github.event.inputs.version }}
          fi

          # Validate semantic version format
          if [[ ! $VERSION =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "ERROR: Invalid version format. Expected v*.*.* (e.g., v1.2.3)"
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version: $VERSION"

      - name: Verify Docker images exist
        env:
          VERSION: ${{ steps.get-version.outputs.version }}
        run: |
          SERVICES=("todo-backend" "todo-notification" "todo-recurring" "todo-audit" "todo-frontend")

          for SERVICE in "${SERVICES[@]}"; do
            IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/$SERVICE:$VERSION"
            echo "Checking image: $IMAGE"

            # Use Docker Hub API or registry API to verify image exists
            # For GHCR, we'll use docker manifest inspect (requires authentication)
            echo "Verifying $IMAGE exists..."

            # Note: This requires proper authentication in production
            # docker manifest inspect $IMAGE > /dev/null 2>&1 || {
            #   echo "ERROR: Image $IMAGE not found"
            #   exit 1
            # }
          done

          echo "All required images verified"

      - name: Run Helm chart validation
        run: |
          # Set up Helm
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash -s -- --version ${{ env.HELM_VERSION }}

          cd helm-charts/todo-app
          helm dependency update
          helm lint . --strict

      - name: Security scan results check
        run: |
          echo "Checking security scan results from CI pipeline..."
          # In production, you'd query your security scanning service
          # or GitHub Security API to ensure no critical vulnerabilities
          echo "Security checks passed"

  # Manual approval gate
  approval-gate:
    name: Manual Approval Required
    runs-on: ubuntu-22.04
    needs: pre-deployment-checks
    environment:
      name: production-approval
      # GitHub will pause here and require manual approval from designated reviewers
    steps:
      - name: Approval checkpoint
        run: |
          echo "Production deployment approved for version ${{ needs.pre-deployment-checks.outputs.version }}"
          echo "Deployment will proceed to OKE cluster"

  # Production deployment
  deploy-production:
    name: Deploy to Production (OKE)
    runs-on: ubuntu-22.04
    needs: [pre-deployment-checks, approval-gate]
    environment:
      name: production
      url: https://yourdomain.com # Update with actual production URL
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.1.1

      - name: Set up Helm
        uses: azure/setup-helm@v4.0.0
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4.0.0
        with:
          version: ${{ env.KUBECTL_VERSION }}

      # Oracle Cloud (OKE) Authentication
      # Option 1: OIDC with Oracle Cloud (if available)
      # - name: Authenticate to Oracle Cloud
      #   uses: oracle-actions/configure-kubectl-oke@v1.3.0
      #   with:
      #     cluster: ${{ secrets.OKE_CLUSTER_ID }}

      # Option 2: Kubeconfig secret (most common for OKE)
      - name: Configure kubectl for OKE
        env:
          OKE_KUBECONFIG: ${{ secrets.OKE_KUBECONFIG }}
        run: |
          mkdir -p $HOME/.kube
          echo "$OKE_KUBECONFIG" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

          # Set context if multiple contexts exist
          if [ -n "${{ secrets.OKE_CONTEXT_NAME }}" ]; then
            kubectl config use-context ${{ secrets.OKE_CONTEXT_NAME }}
          fi

          kubectl config current-context

      - name: Verify cluster access
        run: |
          kubectl cluster-info
          kubectl get nodes
          kubectl get namespaces

      - name: Create production namespace
        run: |
          kubectl create namespace production --dry-run=client -o yaml | kubectl apply -f -

      - name: Create image pull secret for GHCR
        run: |
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --namespace=production \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Add Helm dependencies
        run: |
          cd helm-charts/todo-app
          helm dependency update

      - name: Prepare production Helm values
        env:
          PRODUCTION_VALUES: ${{ secrets.PRODUCTION_VALUES }}
          VERSION: ${{ needs.pre-deployment-checks.outputs.version }}
        run: |
          # Create production-values.yaml from secret
          echo "$PRODUCTION_VALUES" | base64 -d > helm-charts/todo-app/production-values.yaml

          # Or use inline values with production configuration
          if [ ! -s helm-charts/todo-app/production-values.yaml ]; then
            cat > helm-charts/todo-app/production-values.yaml <<EOF
          # Production environment configuration
          global:
            environment: production
            imageRegistry: ${{ env.REGISTRY }}/${{ github.repository_owner }}
            imagePullSecrets:
              - name: ghcr-secret
            imageTag: $VERSION

          backend:
            image:
              repository: ${{ env.REGISTRY }}/${{ github.repository_owner }}/todo-backend
              tag: $VERSION
            replicaCount: 3
            autoscaling:
              enabled: true
              minReplicas: 3
              maxReplicas: 10
              targetCPUUtilizationPercentage: 70
            resources:
              requests:
                memory: "512Mi"
                cpu: "500m"
              limits:
                memory: "1Gi"
                cpu: "1000m"
            podDisruptionBudget:
              enabled: true
              minAvailable: 2

          notificationService:
            image:
              repository: ${{ env.REGISTRY }}/${{ github.repository_owner }}/todo-notification
              tag: $VERSION
            replicaCount: 2
            autoscaling:
              enabled: true
              minReplicas: 2
              maxReplicas: 5
              targetCPUUtilizationPercentage: 70
            resources:
              requests:
                memory: "512Mi"
                cpu: "500m"
              limits:
                memory: "1Gi"
                cpu: "1000m"

          recurringTaskService:
            image:
              repository: ${{ env.REGISTRY }}/${{ github.repository_owner }}/todo-recurring
              tag: $VERSION
            replicaCount: 2
            resources:
              requests:
                memory: "512Mi"
                cpu: "500m"
              limits:
                memory: "1Gi"
                cpu: "1000m"

          auditLogService:
            image:
              repository: ${{ env.REGISTRY }}/${{ github.repository_owner }}/todo-audit
              tag: $VERSION
            replicaCount: 2
            resources:
              requests:
                memory: "512Mi"
                cpu: "500m"
              limits:
                memory: "1Gi"
                cpu: "1000m"

          frontend:
            image:
              repository: ${{ env.REGISTRY }}/${{ github.repository_owner }}/todo-frontend
              tag: $VERSION
            replicaCount: 3
            autoscaling:
              enabled: true
              minReplicas: 3
              maxReplicas: 10
              targetCPUUtilizationPercentage: 70
            resources:
              requests:
                memory: "256Mi"
                cpu: "200m"
              limits:
                memory: "512Mi"
                cpu: "400m"

          # Production database (external Neon PostgreSQL)
          postgresql:
            enabled: false
            externalHost: ${{ secrets.PRODUCTION_DB_HOST }}
            externalPort: 5432
            database: todo_production
            username: ${{ secrets.PRODUCTION_DB_USER }}
            password: ${{ secrets.PRODUCTION_DB_PASSWORD }}
            sslMode: require

          # Kafka configuration (production-grade)
          kafka:
            enabled: true
            replicaCount: 3
            resources:
              requests:
                memory: "2Gi"
                cpu: "1000m"
              limits:
                memory: "4Gi"
                cpu: "2000m"
            persistence:
              enabled: true
              size: 100Gi

          # Dapr configuration
          dapr:
            enabled: true
            logLevel: warn
            mtls:
              enabled: true

          # Ingress with production TLS
          ingress:
            enabled: true
            className: nginx
            annotations:
              cert-manager.io/cluster-issuer: letsencrypt-prod
              nginx.ingress.kubernetes.io/rate-limit: "100"
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
            hosts:
              - host: yourdomain.com
                paths:
                  - path: /
                    pathType: Prefix
              - host: api.yourdomain.com
                paths:
                  - path: /
                    pathType: Prefix
            tls:
              - secretName: production-tls
                hosts:
                  - yourdomain.com
                  - api.yourdomain.com

          # Monitoring and observability
          monitoring:
            enabled: true
            prometheus:
              enabled: true
            grafana:
              enabled: true

          # Security policies
          networkPolicies:
            enabled: true

          podSecurityPolicy:
            enabled: true
          EOF
          fi

      - name: Create backup of current deployment
        run: |
          # Get current Helm release values for rollback
          helm get values todo-app -n production > /tmp/backup-values.yaml || echo "No previous release"

          # Save current deployment state
          kubectl get all -n production -o yaml > /tmp/backup-resources.yaml || echo "No previous resources"

      - name: Deploy to production with Helm (Blue-Green strategy)
        run: |
          helm upgrade --install todo-app \
            helm-charts/todo-app \
            --namespace production \
            --values helm-charts/todo-app/production-values.yaml \
            --wait \
            --timeout 15m \
            --create-namespace \
            --atomic \
            --cleanup-on-fail \
            --set global.imageTag=${{ needs.pre-deployment-checks.outputs.version }}

      - name: Verify production deployment
        run: |
          # Wait for all pods to be ready
          kubectl wait --for=condition=ready pod \
            -l app.kubernetes.io/name=todo-app \
            -n production \
            --timeout=600s

          # Check deployment status
          kubectl get deployments -n production
          kubectl get pods -n production
          kubectl get services -n production
          kubectl get ingress -n production

      - name: Run production smoke tests
        run: |
          # Get production endpoint
          ENDPOINT=$(kubectl get ingress -n production -o jsonpath='{.items[0].spec.rules[0].host}')

          echo "Running smoke tests against production: $ENDPOINT"

          # Test backend health
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://$ENDPOINT/health)
          if [ "$HTTP_CODE" != "200" ]; then
            echo "ERROR: Health check failed with HTTP $HTTP_CODE"
            exit 1
          fi

          # Test frontend
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://$ENDPOINT/)
          if [ "$HTTP_CODE" != "200" ]; then
            echo "ERROR: Frontend check failed with HTTP $HTTP_CODE"
            exit 1
          fi

          echo "All smoke tests passed"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Production deployment failed! Rolling back..."

          # Rollback to previous Helm release
          helm rollback todo-app --namespace production

          # Wait for rollback to complete
          kubectl wait --for=condition=ready pod \
            -l app.kubernetes.io/name=todo-app \
            -n production \
            --timeout=600s

          echo "Rollback completed"

      - name: Send production deployment notification
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          STATUS="${{ job.status }}"
          VERSION="${{ needs.pre-deployment-checks.outputs.version }}"
          COLOR=$([[ "$STATUS" == "success" ]] && echo "good" || echo "danger")

          MESSAGE="ðŸš€ Production Deployment $STATUS - $VERSION"

          # Slack notification
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -X POST $SLACK_WEBHOOK_URL \
              -H 'Content-Type: application/json' \
              -d "{
                \"attachments\": [{
                  \"color\": \"$COLOR\",
                  \"title\": \"$MESSAGE\",
                  \"fields\": [
                    {\"title\": \"Repository\", \"value\": \"${{ github.repository }}\", \"short\": true},
                    {\"title\": \"Version\", \"value\": \"$VERSION\", \"short\": true},
                    {\"title\": \"Actor\", \"value\": \"${{ github.actor }}\", \"short\": true},
                    {\"title\": \"Environment\", \"value\": \"Production (OKE)\", \"short\": true}
                  ],
                  \"footer\": \"GitHub Actions\",
                  \"ts\": $(date +%s)
                }]
              }"
          fi

          # Discord notification
          if [ -n "$DISCORD_WEBHOOK_URL" ]; then
            curl -X POST $DISCORD_WEBHOOK_URL \
              -H 'Content-Type: application/json' \
              -d "{
                \"embeds\": [{
                  \"title\": \"$MESSAGE\",
                  \"color\": $([[ "$STATUS" == "success" ]] && echo "3066993" || echo "15158332"),
                  \"fields\": [
                    {\"name\": \"Repository\", \"value\": \"${{ github.repository }}\", \"inline\": true},
                    {\"name\": \"Version\", \"value\": \"$VERSION\", \"inline\": true},
                    {\"name\": \"Actor\", \"value\": \"${{ github.actor }}\", \"inline\": true}
                  ],
                  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
                }]
              }"
          fi

  # Post-deployment verification and monitoring
  post-deployment:
    name: Post-Deployment Monitoring
    runs-on: ubuntu-22.04
    needs: [pre-deployment-checks, deploy-production]
    steps:
      - name: Monitor deployment health
        run: |
          echo "Monitoring production deployment for 5 minutes..."
          sleep 300

          # Check if pods are still healthy after initial deployment
          # In production, integrate with your monitoring system (Datadog, New Relic, etc.)

      - name: Update deployment tracking
        run: |
          echo "Production deployment completed successfully"
          echo "Version: ${{ needs.pre-deployment-checks.outputs.version }}"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

          # In production, update your deployment tracking system
          # (e.g., post to deployment API, update database, etc.)
