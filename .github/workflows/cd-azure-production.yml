# Azure AKS Production Deployment Pipeline
name: Deploy to Azure AKS (Production)

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy (e.g., v1.0.0)'
        required: true
      skip_approval:
        description: 'Skip manual approval (use with caution)'
        type: boolean
        default: false

env:
  AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
  AKS_CLUSTER_NAME: ${{ secrets.AKS_CLUSTER_NAME }}
  ACR_NAME: ${{ secrets.ACR_NAME }}
  NAMESPACE: production

jobs:
  validate:
    name: Validate Release
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.tag.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine image tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            echo "version=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          else
            echo "version=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          fi

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Verify images exist in ACR
        run: |
          TAG=${{ steps.tag.outputs.version }}
          SERVICES=("todo-backend" "todo-frontend" "notification-service" "recurring-task-service" "audit-log-service")

          for SERVICE in "${SERVICES[@]}"; do
            echo "Checking $SERVICE:$TAG..."
            az acr repository show-tags --name ${{ env.ACR_NAME }} --repository $SERVICE --query "[?contains(@, '$TAG')]" -o tsv
            if [ $? -ne 0 ]; then
              echo "Error: Image $SERVICE:$TAG not found in ACR"
              exit 1
            fi
          done
          echo "All images verified successfully!"

      - name: Helm lint
        run: |
          helm lint ./helm-charts/todo-app -f ./helm-charts/todo-app/values-azure.yaml

  build-if-needed:
    name: Build Images (if not exists)
    needs: validate
    runs-on: ubuntu-latest
    if: failure() || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and push all images
        run: |
          TAG=${{ needs.validate.outputs.image_tag }}

          # Backend
          docker build -t ${{ env.ACR_NAME }}.azurecr.io/todo-backend:$TAG ./backend/hf_deployment
          docker push ${{ env.ACR_NAME }}.azurecr.io/todo-backend:$TAG

          # Frontend
          docker build -t ${{ env.ACR_NAME }}.azurecr.io/todo-frontend:$TAG ./frontend
          docker push ${{ env.ACR_NAME }}.azurecr.io/todo-frontend:$TAG

          # Microservices
          docker build -t ${{ env.ACR_NAME }}.azurecr.io/notification-service:$TAG ./backend/services/notification-service
          docker push ${{ env.ACR_NAME }}.azurecr.io/notification-service:$TAG

          docker build -t ${{ env.ACR_NAME }}.azurecr.io/recurring-task-service:$TAG ./backend/services/recurring-task-service
          docker push ${{ env.ACR_NAME }}.azurecr.io/recurring-task-service:$TAG

          docker build -t ${{ env.ACR_NAME }}.azurecr.io/audit-log-service:$TAG ./backend/services/audit-log-service
          docker push ${{ env.ACR_NAME }}.azurecr.io/audit-log-service:$TAG

  approval:
    name: Production Approval
    needs: [validate]
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_approval != 'true'
    environment: production-approval

    steps:
      - name: Request approval
        run: |
          echo "## Production Deployment Request" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** ${{ needs.validate.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Please review and approve to proceed with production deployment." >> $GITHUB_STEP_SUMMARY

  deploy:
    name: Deploy to AKS Production
    needs: [validate, approval]
    if: always() && (needs.approval.result == 'success' || github.event.inputs.skip_approval == 'true')
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.AZURE_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create ACR pull secret
        run: |
          kubectl create secret docker-registry acr-secret \
            --namespace ${{ env.NAMESPACE }} \
            --docker-server=${{ env.ACR_NAME }}.azurecr.io \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Azure secrets
        run: |
          kubectl create secret generic azure-secrets \
            --namespace ${{ env.NAMESPACE }} \
            --from-literal=database-url="${{ secrets.AZURE_DATABASE_URL_PROD }}" \
            --from-literal=redis-url="${{ secrets.AZURE_REDIS_URL_PROD }}" \
            --from-literal=eventhub-connection="${{ secrets.AZURE_EVENTHUB_CONNECTION_PROD }}" \
            --from-literal=jwt-secret="${{ secrets.JWT_SECRET_PROD }}" \
            --from-literal=openai-api-key="${{ secrets.OPENAI_API_KEY }}" \
            --from-literal=appinsights-key="${{ secrets.APPINSIGHTS_INSTRUMENTATIONKEY }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.0'

      - name: Update Helm dependencies
        run: |
          cd helm-charts/todo-app
          helm dependency update

      - name: Pre-deployment backup
        run: |
          # Backup current deployment state
          kubectl get deployment -n ${{ env.NAMESPACE }} -o yaml > /tmp/deployment-backup.yaml || true
          echo "Current deployment state backed up"

      - name: Blue-Green Deployment
        run: |
          IMAGE_TAG=${{ needs.validate.outputs.image_tag }}

          # Deploy with Helm (Blue-Green strategy)
          helm upgrade --install todo-app ./helm-charts/todo-app \
            --namespace ${{ env.NAMESPACE }} \
            --values ./helm-charts/todo-app/values-azure.yaml \
            --set global.registry=${{ env.ACR_NAME }}.azurecr.io \
            --set services.frontend.image=${{ env.ACR_NAME }}.azurecr.io/todo-frontend:$IMAGE_TAG \
            --set services.backend.image=${{ env.ACR_NAME }}.azurecr.io/todo-backend:$IMAGE_TAG \
            --set services.notification.image=${{ env.ACR_NAME }}.azurecr.io/notification-service:$IMAGE_TAG \
            --set services.recurring.image=${{ env.ACR_NAME }}.azurecr.io/recurring-task-service:$IMAGE_TAG \
            --set services.audit.image=${{ env.ACR_NAME }}.azurecr.io/audit-log-service:$IMAGE_TAG \
            --set replicaCount=3 \
            --set autoscaling.enabled=true \
            --set autoscaling.minReplicas=3 \
            --set autoscaling.maxReplicas=20 \
            --set podDisruptionBudget.enabled=true \
            --set podDisruptionBudget.minAvailable=2 \
            --wait \
            --timeout 15m \
            --atomic

      - name: Verify deployment
        run: |
          echo "Waiting for deployments to be ready..."
          kubectl rollout status deployment/todo-app-backend -n ${{ env.NAMESPACE }} --timeout=10m
          kubectl rollout status deployment/todo-app-frontend -n ${{ env.NAMESPACE }} --timeout=10m

          echo ""
          echo "=== Pod Status ==="
          kubectl get pods -n ${{ env.NAMESPACE }}

          echo ""
          echo "=== Services ==="
          kubectl get svc -n ${{ env.NAMESPACE }}

          echo ""
          echo "=== Ingress ==="
          kubectl get ingress -n ${{ env.NAMESPACE }}

          echo ""
          echo "=== HPA Status ==="
          kubectl get hpa -n ${{ env.NAMESPACE }}

      - name: Health checks
        run: |
          # Get the ingress IP/hostname
          INGRESS_HOST=$(kubectl get ingress todo-app -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -z "$INGRESS_HOST" ]; then
            INGRESS_HOST=$(kubectl get ingress todo-app -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          fi

          echo "Ingress Host: $INGRESS_HOST"

          # Health check with retries
          for i in {1..10}; do
            if curl -sf "http://$INGRESS_HOST/health" -H "Host: api.todo-app.${{ secrets.AZURE_DNS_ZONE }}" > /dev/null 2>&1; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Health check attempt $i failed, retrying in 30s..."
            sleep 30
          done

          echo "Warning: Health check did not pass within timeout, but deployment completed."

      - name: Post deployment notification
        if: always()
        run: |
          echo "## Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Namespace:** ${{ env.NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** ${{ needs.validate.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY

  rollback:
    name: Rollback (if needed)
    needs: [validate, deploy]
    if: failure() && needs.deploy.result == 'failure'
    runs-on: ubuntu-latest

    steps:
      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.AZURE_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      - name: Rollback deployment
        run: |
          echo "Deployment failed. Initiating rollback..."
          helm rollback todo-app -n ${{ env.NAMESPACE }}

          echo "Rollback completed. Verifying..."
          kubectl get pods -n ${{ env.NAMESPACE }}

      - name: Notify rollback
        run: |
          echo "## ROLLBACK EXECUTED" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Production deployment failed and was rolled back to previous version." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Failed Tag:** ${{ needs.validate.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Action Required:** Investigate failure and fix before re-deploying." >> $GITHUB_STEP_SUMMARY
