<!--
SYNC IMPACT REPORT
==================
Version Change: 1.0.0 â†’ 2.0.0
Date: 2025-12-25

Major Version Bump Rationale:
- Complete rewrite to Spec-Kit Plus comprehensive format
- Added 5 new major sections (UI Specifications, Data Model, Feature Matrix, Appendices, Quality Assurance)
- Restructured from 7 principles to 10 comprehensive principles aligned with hackathon requirements
- Backward incompatible change: Spec-driven development now strictly enforced (no manual coding)

Modified Principles:
- I. Simplicity First â†’ I. Spec-Driven Development First (NON-NEGOTIABLE)
- II. Clean Code â†’ II. Simplicity and Clean Code
- III. User Experience â†’ III. User Experience Excellence
- IV. Data Integrity â†’ IV. Data Integrity and Validation
- V. Testability â†’ V. Modularity and Testability
- VI. Project Structure â†’ VI. Standard Project Structure
- VII. Spec-Driven â†’ VII. Python Code Quality Standards

Added Principles:
- VIII. CLI Interface Excellence
- IX. Performance and Resource Efficiency
- X. Version Control and Documentation

Added Sections:
- Technology Stack (comprehensive table format)
- Data Model Specification (complete Task structure)
- Feature Specifications (all 5 basic features)
- UI Specifications (CLI menus, prompts, outputs)
- Development Workflow (detailed 8-step process)
- Folder Structure (complete directory tree)
- Quality Assurance & Success Criteria
- Appendices (spec templates, Claude Code instructions, testing checklist)

Template Consistency:
âœ… spec-template.md - Aligned with user story format
âœ… plan-template.md - Constitution Check references updated
âœ… tasks-template.md - Task organization aligned with feature phases
âœ… phr-template.prompt.md - No changes needed (generic)

Follow-up TODOs:
- None - all placeholders filled
-->

# Todo Evolution - Phase I Constitution

**Project**: Hackathon II - The Evolution of Todo (Phase I)
**Phase**: I - In-Memory Python Console Application
**Technology**: Python 3.13+ | UV Package Manager | Claude Code | Spec-Kit Plus
**Version**: 2.0.0 | **Ratified**: 2025-12-25 | **Last Amended**: 2025-12-25

---

## 1. Project Identity

### 1.1 Mission Statement

Build a command-line todo application in Python that demonstrates mastery of Spec-Driven Development (SDD) principles using Claude Code and Spec-Kit Plus. This Phase I implementation serves as the foundation for a progressive evolution toward cloud-native AI systems, focusing on clean architecture, testable code, and excellent user experience through the CLI.

### 1.2 Phase I Objectives

1. **Learn Spec-Driven Development**: Master the art of writing specifications that Claude Code can transform into working software
2. **Build Foundation**: Create a solid, well-architected console application that will evolve through 5 phases
3. **Demonstrate Competency**: Implement all 5 Basic Level features with production-quality code
4. **Prepare for Evolution**: Design with future phases in mind while keeping Phase I scope focused and simple

### 1.3 Success Metrics

- 100% of code generated by Claude Code from specifications (zero manual coding)
- All 5 Basic Level features fully functional and tested
- Clean, readable code scoring â‰¥8.0 on linting tools
- â‰¥80% test coverage with all tests passing
- Application deliverable by December 7, 2025 (100 points)

---

## 2. Core Principles

### I. Spec-Driven Development First (NON-NEGOTIABLE)

**Rule**: Every feature MUST have a detailed specification written BEFORE any code is generated.

**Requirements**:
- Write specifications in `/specs/phase-1/` directory using Spec-Kit Plus templates
- Include: user stories, acceptance criteria, input/output examples, edge cases
- Submit specifications to Claude Code for implementation
- NEVER write code manually - all code must be Claude Code generated
- If generated code is incorrect, refine the specification, not the code
- Iterate on specs until Claude Code produces correct output
- Document all spec changes with rationale in spec file

**Rationale**: This constraint teaches architectural thinking and precise requirements specification - essential skills for AI-driven development. Manual coding is prohibited to force mastery of spec-driven methodology.

### II. Simplicity and Clean Code

**Rule**: Start with the simplest implementation that satisfies requirements. Code must be self-documenting and readable.

**Requirements**:
- Use in-memory data structures (Python lists/dictionaries) - no databases in Phase I
- Follow PEP 8 Python style guidelines strictly
- Use descriptive variable and function names that explain intent
- Keep functions focused on single responsibility
- Maximum 20 lines per function
- Use type hints for all function signatures
- Add docstrings to all functions with parameter and return documentation
- No premature optimization or over-engineering

**Rationale**: Simple code is maintainable code. Clear naming and structure reduce cognitive load and make the codebase accessible to future developers (and future AI agents).

### III. User Experience Excellence

**Rule**: The CLI interface must be intuitive, helpful, and pleasant to use.

**Requirements**:
- Provide clear prompts for all user inputs
- Display meaningful error messages that guide users toward correct actions
- Use formatted output (tables, visual separators) for readability
- Show status indicators (âœ“, âœ—, â€¢) for task completion
- Support both interactive menu mode and direct command execution
- Confirm destructive operations (delete) before executing
- Display helpful feedback after every operation
- Handle invalid inputs gracefully with clear guidance

**Rationale**: User experience is paramount. A well-designed CLI teaches users through interaction and reduces frustration, making the application a pleasure to use.

### IV. Data Integrity and Validation

**Rule**: All data operations must maintain consistency and validate inputs rigorously.

**Requirements**:
- Task IDs must be unique and auto-incrementing (never reuse IDs)
- Validate all user inputs before processing (title length, ID existence)
- Prevent operations on non-existent tasks with clear error messages
- Maintain data consistency throughout application lifecycle
- Task status must be boolean (completed: True/False), not ambiguous strings
- Timestamps (created_at, updated_at) must be automatically managed
- Title: required, 1-200 characters
- Description: optional, max 1000 characters

**Rationale**: Data integrity prevents bugs and confusion. Rigorous validation catches errors early and provides helpful feedback rather than silent failures or corruption.

### V. Modularity and Testability

**Rule**: Code must be structured to enable easy testing and future evolution.

**Requirements**:
- Separate concerns into distinct modules:
  - **Data layer**: Task model and in-memory storage
  - **Business logic**: CRUD operations and validation
  - **Presentation layer**: CLI interface and formatting
- Write pure functions where possible (no side effects)
- Use dependency injection for testability
- Achieve minimum 80% code coverage
- Every feature must have corresponding test cases
- Use pytest framework for testing
- Tests must be independent (no shared state between tests)

**Rationale**: Modular code is testable code. Clean separation of concerns makes the codebase easier to understand, test, and evolve through subsequent phases.

### VI. Standard Project Structure

**Rule**: Follow Python best practices for project organization.

**Directory Structure**:
```
/
â”œâ”€â”€ .specify/                    # Spec-Kit Plus configuration
â”‚   â”œâ”€â”€ memory/
â”‚   â”‚   â””â”€â”€ constitution.md      # This file
â”‚   â”œâ”€â”€ templates/               # Spec templates
â”‚   â””â”€â”€ scripts/                 # Helper scripts
â”œâ”€â”€ specs/                       # Specifications directory
â”‚   â””â”€â”€ phase-1/                 # Phase I specs
â”‚       â”œâ”€â”€ spec.md              # Main feature spec
â”‚       â”œâ”€â”€ plan.md              # Implementation plan
â”‚       â””â”€â”€ tasks.md             # Task breakdown
â”œâ”€â”€ history/                     # Development history
â”‚   â”œâ”€â”€ prompts/                 # Prompt History Records
â”‚   â””â”€â”€ adr/                     # Architecture Decision Records
â”œâ”€â”€ src/                         # Source code
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py                  # Application entry point
â”‚   â”œâ”€â”€ models/                  # Data models
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ task.py              # Task model
â”‚   â”œâ”€â”€ services/                # Business logic
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ task_service.py      # Task CRUD operations
â”‚   â””â”€â”€ cli/                     # CLI interface
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ menu.py              # Interactive menu
â”‚       â””â”€â”€ formatter.py         # Output formatting
â”œâ”€â”€ tests/                       # Test suite
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_task_model.py       # Model tests
â”‚   â”œâ”€â”€ test_task_service.py     # Service tests
â”‚   â””â”€â”€ test_cli.py              # CLI tests
â”œâ”€â”€ pyproject.toml               # Project config (uv)
â”œâ”€â”€ README.md                    # Setup and usage guide
â”œâ”€â”€ CLAUDE.md                    # Claude Code instructions
â””â”€â”€ .gitignore                   # Git ignore file
```

**Rationale**: Standard structure makes the project immediately recognizable to any Python developer and facilitates tool integration (linters, IDE support, CI/CD).

### VII. Python Code Quality Standards

**Rule**: All code must meet rigorous quality standards.

**Requirements**:
- Type checking with mypy: zero type errors allowed
- Linting with pylint/flake8: score â‰¥8.0 required
- All functions must have docstrings with parameter types and descriptions
- Use type hints consistently throughout codebase
- Handle exceptions with try-except blocks (never silent failures)
- Log errors with context for debugging
- No commented-out code in production (remove or explain)
- No print statements for debugging (use logging module)

**Rationale**: Quality standards prevent technical debt and ensure code is maintainable. Type hints catch bugs at development time rather than runtime.

### VIII. CLI Interface Excellence

**Rule**: The command-line interface must follow CLI best practices.

**Requirements**:
- Interactive menu mode as primary interface
- Display numbered menu options (1-6)
- Accept single-key or number input for menu navigation
- Show current task count in menu header
- Display operation results immediately after execution
- Use visual separators (lines, spacing) for readability
- Optional: Use colors for status (green=complete, red=error, yellow=pending)
- Support Ctrl+C graceful exit at any point
- Clear screen between operations (optional, for cleaner UX)

**Rationale**: A well-designed CLI feels responsive and intuitive. Visual hierarchy and clear feedback make the application easy to learn and use.

### IX. Performance and Resource Efficiency

**Rule**: The application must be fast and lightweight.

**Performance Targets**:
- Application startup: <1 second
- All CRUD operations: <100ms
- Support 1000+ tasks in memory without degradation
- Memory usage: <50MB for typical usage (â‰¤100 tasks)
- No memory leaks (all resources properly released)

**Rationale**: Performance matters even for simple applications. Good performance habits established early carry forward through all phases.

### X. Version Control and Documentation

**Rule**: All work must be tracked and documented.

**Requirements**:
- Use Git for version control with meaningful commit messages
- Commit format: `<type>: <description>` (e.g., `feat: add task creation`)
- Commit after each completed feature or logical unit
- README.md must include:
  - Project description and phase info
  - Installation instructions (uv setup)
  - Usage guide with examples
  - Running tests instructions
- CLAUDE.md must include:
  - Constitution reference
  - Spec-driven workflow instructions
  - File structure explanation
- Keep documentation in sync with code

**Rationale**: Good documentation and version control practices are professional standards. Clear history enables understanding evolution and debugging issues.

---

## 3. Technology Stack

| Category | Technology | Version | Purpose | Required |
|----------|-----------|---------|---------|----------|
| **Language** | Python | 3.13+ | Core programming language | âœ… Yes |
| **Package Manager** | UV | Latest | Dependency management, fast installs | âœ… Yes |
| **Spec Framework** | Spec-Kit Plus | Latest | Specification-driven development | âœ… Yes |
| **AI Coding Assistant** | Claude Code | Latest | Code generation from specs | âœ… Yes |
| **Testing Framework** | pytest | 8.0+ | Unit and integration testing | âœ… Yes |
| **Type Checking** | mypy | 1.8+ | Static type analysis | âœ… Yes |
| **Linting** | pylint/flake8 | Latest | Code quality checking | âœ… Yes |
| **CLI Formatting** | rich | 13.0+ | Terminal colors and tables | â­• Optional |
| **Alternative Formatting** | colorama | 0.4+ | Cross-platform colors | â­• Optional |
| **Storage** | In-Memory (dict/list) | N/A | Task storage (Phase I only) | âœ… Yes |

### 3.1 Dependency Rationale

**Why UV?**
- 10-100x faster than pip
- Built-in virtual environment management
- Better dependency resolution
- Modern Python tooling

**Why pytest?**
- More intuitive than unittest
- Better test discovery
- Powerful fixtures
- Extensive plugin ecosystem

**Why rich (optional)?**
- Beautiful terminal output
- Built-in table formatting
- Progress indicators
- Syntax highlighting

**Why in-memory storage?**
- Simplicity for Phase I (no database complexity)
- Focuses learning on architecture and SDD
- Easy to test and reason about
- Will be replaced with Neon PostgreSQL in Phase II

---

## 4. Data Model Specification

### 4.1 Task Entity

The core data entity for Phase I is the **Task**. It must contain the following fields:

| Field | Type | Constraints | Default | Description |
|-------|------|-------------|---------|-------------|
| `id` | `int` | Unique, auto-increment, >0 | Auto-generated | Unique identifier, never reused |
| `title` | `str` | Required, 1-200 chars | None | Brief task description |
| `description` | `str` | Optional, max 1000 chars | `""` | Detailed task information |
| `completed` | `bool` | Required | `False` | Completion status |
| `created_at` | `datetime` | Auto-generated, UTC | Current timestamp | When task was created |
| `updated_at` | `datetime` | Auto-updated, UTC | Current timestamp | Last modification time |

### 4.2 Data Structure

**Python Implementation** (as dataclass or dict):

```python
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Task:
    id: int
    title: str
    description: str = ""
    completed: bool = False
    created_at: datetime = None
    updated_at: datetime = None

    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.utcnow()
        if self.updated_at is None:
            self.updated_at = datetime.utcnow()
```

**Storage**: Tasks stored in Python list: `tasks: list[Task] = []`

### 4.3 Data Validation Rules

1. **Title Validation**:
   - Must not be empty or whitespace-only
   - Length: 1-200 characters (after strip())
   - Error message: "Title must be between 1 and 200 characters"

2. **Description Validation**:
   - Optional (empty string allowed)
   - Maximum 1000 characters
   - Error message: "Description cannot exceed 1000 characters"

3. **ID Management**:
   - Auto-increment starting from 1
   - Never reuse IDs (even after deletion)
   - IDs are immutable once assigned

4. **Timestamp Management**:
   - `created_at`: Set once at creation, never modified
   - `updated_at`: Updated on every modification (title, description, completed)
   - All timestamps in UTC

---

## 5. Feature Specifications

Phase I implements the **5 Basic Level Features** as specified in the hackathon requirements:

### Feature 1: Add Task

**User Story**: As a user, I want to add a new task with a title and optional description, so I can track things I need to do.

**Acceptance Criteria**:
1. User can enter a task title (required)
2. User can optionally enter a description
3. System assigns unique auto-incrementing ID
4. System sets created_at and updated_at timestamps
5. Task is marked as incomplete (completed=False) by default
6. System confirms task creation with ID and title

**Input Validation**:
- Title: 1-200 characters (reject empty/whitespace)
- Description: 0-1000 characters

**Example Interaction**:
```
=== Add New Task ===
Enter task title: Buy groceries
Enter description (optional): Milk, eggs, bread, butter

âœ“ Task created successfully!
ID: 1 | Title: Buy groceries
```

---

### Feature 2: View Task List

**User Story**: As a user, I want to view all my tasks in a formatted list, so I can see what I need to do and what I've completed.

**Acceptance Criteria**:
1. Display all tasks in a readable table format
2. Show ID, title, status (âœ“ complete / â€¢ pending), created date
3. Display count of total/completed/pending tasks
4. Handle empty list gracefully ("No tasks found")
5. Sort by creation date (newest first) or ID

**Display Format**:
```
=== Task List (3 tasks: 1 completed, 2 pending) ===

ID  | Status | Title                  | Created
----|--------|------------------------|------------
1   | âœ“      | Buy groceries          | 2025-12-25
2   | â€¢      | Call dentist           | 2025-12-25
3   | â€¢      | Finish project report  | 2025-12-25
```

---

### Feature 3: Update Task

**User Story**: As a user, I want to update a task's title or description, so I can correct mistakes or add more detail.

**Acceptance Criteria**:
1. User selects task by ID
2. System validates task ID exists
3. User can update title (required, 1-200 chars)
4. User can update description (optional, max 1000 chars)
5. System updates updated_at timestamp
6. System confirms update with modified fields

**Example Interaction**:
```
=== Update Task ===
Enter task ID to update: 1
Current title: Buy groceries
New title (or press Enter to keep): Buy groceries and fruits
Current description: Milk, eggs, bread, butter
New description (or press Enter to keep): Milk, eggs, bread, butter, apples

âœ“ Task updated successfully!
ID: 1 | Title: Buy groceries and fruits
```

---

### Feature 4: Delete Task

**User Story**: As a user, I want to delete a task I no longer need, so my task list stays relevant and uncluttered.

**Acceptance Criteria**:
1. User selects task by ID
2. System validates task ID exists
3. System shows task details and asks for confirmation
4. User confirms deletion (Y/N)
5. System removes task from list (ID is never reused)
6. System confirms deletion

**Example Interaction**:
```
=== Delete Task ===
Enter task ID to delete: 2

Task to delete:
ID: 2 | Title: Call dentist | Status: Pending

Are you sure you want to delete this task? (Y/N): Y

âœ“ Task deleted successfully!
```

---

### Feature 5: Mark Task Complete/Incomplete

**User Story**: As a user, I want to mark tasks as complete or incomplete, so I can track my progress.

**Acceptance Criteria**:
1. User selects task by ID
2. System validates task ID exists
3. System toggles completed status (True â†” False)
4. System updates updated_at timestamp
5. System confirms status change with new state

**Example Interaction**:
```
=== Mark Task Complete/Incomplete ===
Enter task ID: 1

Current status: Incomplete (â€¢)

âœ“ Task marked as complete!
ID: 1 | Title: Buy groceries | Status: Complete (âœ“)
```

---

## 6. UI Specifications

### 6.1 Main Menu

The application must present an interactive menu as the primary interface:

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘     Todo App - Phase I (v1.0.0)        â•‘
â•‘     Tasks: 3 total (1 done, 2 pending) â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Choose an option:

  1. Add new task
  2. View all tasks
  3. Update task
  4. Delete task
  5. Mark task complete/incomplete
  6. Exit

Enter your choice (1-6): _
```

**Menu Behavior**:
- Display current task statistics in header
- Accept numeric input (1-6)
- Invalid input: Show error and redisplay menu
- Choice 6: Exit with confirmation message

### 6.2 Input Prompts

All input prompts must be clear and helpful:

**Good Prompts**:
- `Enter task title: _` (clear, direct)
- `Enter task ID to update: _` (specifies what ID is for)
- `New title (or press Enter to keep): _` (shows how to skip)

**Bad Prompts**:
- `Title: _` (too terse, unclear)
- `ID: _` (ambiguous - which ID? for what?)
- `Enter value: _` (what value?)

### 6.3 Output Formatting

**Success Messages** (use âœ“ symbol):
```
âœ“ Task created successfully!
âœ“ Task updated successfully!
âœ“ Task deleted successfully!
```

**Error Messages** (use âœ— symbol):
```
âœ— Error: Task ID 99 not found
âœ— Error: Title must be between 1 and 200 characters
âœ— Error: Invalid choice. Please enter 1-6.
```

**Tables** (use borders and alignment):
```
ID  | Status | Title                  | Created
----|--------|------------------------|------------
1   | âœ“      | Buy groceries          | 2025-12-25
```

### 6.4 Edge Case Handling

1. **Empty Task List**:
   ```
   No tasks found. Add your first task using option 1!
   ```

2. **Invalid ID**:
   ```
   âœ— Error: Task ID 99 not found. Please enter a valid task ID.
   ```

3. **Input Too Long**:
   ```
   âœ— Error: Title cannot exceed 200 characters. Current length: 215
   ```

4. **Empty Title**:
   ```
   âœ— Error: Title cannot be empty. Please enter a task title.
   ```

---

## 7. Development Workflow

### 7.1 Spec-First Process (8 Steps)

This is the REQUIRED workflow for implementing any feature in Phase I:

**Step 1: Write Specification**
- Create spec file in `/specs/phase-1/`
- Use Spec-Kit Plus template from `.specify/templates/spec-template.md`
- Include: user stories, acceptance criteria, examples, edge cases
- Define inputs, outputs, and validation rules
- Review spec for completeness before proceeding

**Step 2: Plan Implementation**
- Reference constitution for architecture guidelines
- Break feature into components (model, service, CLI)
- Identify dependencies and execution order
- Document technical decisions

**Step 3: Submit to Claude Code**
- Provide Claude Code with:
  - Constitution file (this document)
  - Feature specification
  - Existing codebase context
- Request code generation for the feature

**Step 4: Review Generated Code**
- Check adherence to constitution principles
- Verify type hints and docstrings
- Review error handling and validation
- Check code structure (file organization, function size)

**Step 5: Run Quality Checks**
- Type checking: `mypy src/`
- Linting: `pylint src/` or `flake8 src/`
- Tests: `pytest tests/`
- Coverage: `pytest --cov=src tests/`

**Step 6: Test Against Acceptance Criteria**
- Manually test each acceptance scenario from spec
- Verify edge cases are handled
- Check error messages are helpful
- Confirm user experience is smooth

**Step 7: Iterate if Needed**
- If code is incorrect: **refine the specification**, not the code
- Add missing details or constraints to spec
- Re-submit to Claude Code
- Repeat until output is correct

**Step 8: Document and Commit**
- Update README if needed
- Create Prompt History Record (PHR)
- Commit with meaningful message: `feat: add [feature name]`
- Tag completion in tasks.md

### 7.2 Feature Implementation Sequence

Implement features in this order to build incrementally:

1. **Project Setup** (T001-T003)
   - Initialize UV project with pyproject.toml
   - Create folder structure
   - Configure linting and type checking

2. **Data Model** (T004)
   - Implement Task dataclass in `src/models/task.py`
   - Add validation methods
   - Write model tests

3. **Business Logic** (T005-T009)
   - Implement TaskService in `src/services/task_service.py`
   - Add CRUD operations: create, read, update, delete, toggle
   - Write service tests

4. **CLI Interface** (T010-T014)
   - Implement menu system in `src/cli/menu.py`
   - Add formatters in `src/cli/formatter.py`
   - Wire up service calls
   - Write CLI tests

5. **Main Application** (T015)
   - Create `src/main.py` entry point
   - Wire up components
   - Add graceful shutdown

6. **Polish** (T016-T020)
   - Improve error messages
   - Add color formatting (optional)
   - Write README
   - Final testing and coverage check

### 7.3 Quality Gates

Before marking any feature as "complete," it must pass ALL quality gates:

| Gate | Requirement | Command | Pass Threshold |
|------|-------------|---------|----------------|
| Type Check | No type errors | `mypy src/` | 0 errors |
| Linting | Code quality score | `pylint src/` | Score â‰¥8.0 |
| Tests | All tests pass | `pytest tests/` | 100% pass |
| Coverage | Test coverage | `pytest --cov=src` | â‰¥80% coverage |
| Manual Test | All acceptance criteria | User testing | All scenarios work |

**If any gate fails**: Do not proceed. Fix issues by refining specs and regenerating code.

---

## 8. Folder Structure (Complete)

This is the exact folder structure for Phase I:

```
todo-phase-1/
â”‚
â”œâ”€â”€ .specify/                          # Spec-Kit Plus framework
â”‚   â”œâ”€â”€ memory/
â”‚   â”‚   â””â”€â”€ constitution.md            # This constitution file
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â”œâ”€â”€ spec-template.md           # Feature spec template
â”‚   â”‚   â”œâ”€â”€ plan-template.md           # Implementation plan template
â”‚   â”‚   â”œâ”€â”€ tasks-template.md          # Task breakdown template
â”‚   â”‚   â”œâ”€â”€ phr-template.prompt.md     # Prompt history template
â”‚   â”‚   â””â”€â”€ adr-template.md            # Architecture decision template
â”‚   â””â”€â”€ scripts/
â”‚       â””â”€â”€ bash/
â”‚           â”œâ”€â”€ create-phr.sh          # PHR generation script
â”‚           â””â”€â”€ create-adr.sh          # ADR generation script
â”‚
â”œâ”€â”€ specs/                             # Specifications (Spec-Kit Plus)
â”‚   â””â”€â”€ phase-1/
â”‚       â”œâ”€â”€ spec.md                    # Main feature specification
â”‚       â”œâ”€â”€ plan.md                    # Implementation plan
â”‚       â””â”€â”€ tasks.md                   # Task breakdown and tracking
â”‚
â”œâ”€â”€ history/                           # Development history
â”‚   â”œâ”€â”€ prompts/
â”‚   â”‚   â”œâ”€â”€ constitution/              # Constitution-related prompts
â”‚   â”‚   â”œâ”€â”€ phase-1/                   # Phase I prompts
â”‚   â”‚   â””â”€â”€ general/                   # General prompts
â”‚   â””â”€â”€ adr/
â”‚       â””â”€â”€ 001-in-memory-storage.md   # Example ADR
â”‚
â”œâ”€â”€ src/                               # Source code
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py                        # Application entry point
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ task.py                    # Task data model
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ task_service.py            # Business logic (CRUD)
â”‚   â””â”€â”€ cli/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ menu.py                    # Interactive menu system
â”‚       â””â”€â”€ formatter.py               # Output formatting utilities
â”‚
â”œâ”€â”€ tests/                             # Test suite
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py                    # Pytest fixtures
â”‚   â”œâ”€â”€ test_task_model.py             # Task model tests
â”‚   â”œâ”€â”€ test_task_service.py           # Service tests
â”‚   â””â”€â”€ test_cli.py                    # CLI integration tests
â”‚
â”œâ”€â”€ .gitignore                         # Git ignore patterns
â”œâ”€â”€ pyproject.toml                     # UV project configuration
â”œâ”€â”€ README.md                          # Project documentation
â”œâ”€â”€ CLAUDE.md                          # Claude Code instructions
â””â”€â”€ LICENSE                            # Project license (optional)
```

### 8.1 File Size Expectations

| File | Lines (approx) | Purpose |
|------|----------------|---------|
| `src/models/task.py` | 50-80 | Task dataclass, validation |
| `src/services/task_service.py` | 150-200 | All CRUD operations |
| `src/cli/menu.py` | 100-150 | Menu system, input handling |
| `src/cli/formatter.py` | 80-120 | Output formatting, tables |
| `src/main.py` | 20-40 | Entry point, initialization |
| `tests/test_task_model.py` | 100-150 | Model unit tests |
| `tests/test_task_service.py` | 200-300 | Service unit tests |
| `tests/test_cli.py` | 100-150 | CLI integration tests |

---

## 9. Quality Assurance & Success Criteria

### 9.1 Definition of Done (Feature-Level)

A feature is considered "done" when ALL of the following are true:

âœ… **Specification Complete**
- [ ] Feature spec exists in `/specs/phase-1/spec.md`
- [ ] User stories clearly defined with acceptance criteria
- [ ] Edge cases documented
- [ ] Input/output examples provided

âœ… **Code Generated and Reviewed**
- [ ] All code generated by Claude Code (zero manual coding)
- [ ] Code adheres to all constitution principles
- [ ] Type hints present on all functions
- [ ] Docstrings present with parameter descriptions

âœ… **Quality Gates Passed**
- [ ] `mypy src/` â†’ 0 errors
- [ ] `pylint src/` â†’ Score â‰¥8.0
- [ ] `pytest tests/` â†’ 100% pass rate
- [ ] `pytest --cov=src` â†’ â‰¥80% coverage

âœ… **Testing Complete**
- [ ] All acceptance criteria tested manually
- [ ] Edge cases verified (invalid inputs, empty lists, etc.)
- [ ] Error messages are clear and helpful
- [ ] User experience is smooth and intuitive

âœ… **Documentation Updated**
- [ ] README reflects new feature
- [ ] CLAUDE.md updated if workflow changed
- [ ] PHR created in `history/prompts/phase-1/`
- [ ] Commit message describes change

### 9.2 Definition of Done (Phase I Complete)

Phase I is ready for submission when:

âœ… **All 5 Features Implemented**
- [ ] Feature 1: Add Task
- [ ] Feature 2: View Task List
- [ ] Feature 3: Update Task
- [ ] Feature 4: Delete Task
- [ ] Feature 5: Mark Complete/Incomplete

âœ… **Quality Standards Met**
- [ ] No type errors (`mypy`)
- [ ] Linting score â‰¥8.0 (`pylint`)
- [ ] All tests passing (100%)
- [ ] Coverage â‰¥80%
- [ ] Performance targets met (<1s startup, <100ms operations)

âœ… **Documentation Complete**
- [ ] README.md with installation and usage
- [ ] CLAUDE.md with constitution reference
- [ ] All specs in `/specs/phase-1/`
- [ ] PHRs in `history/prompts/phase-1/`

âœ… **Deliverables Ready**
- [ ] Public GitHub repository
- [ ] Demo video (<90 seconds)
- [ ] Submission form completed

### 9.3 Testing Checklist

Run this checklist before submitting Phase I:

**Manual Testing**:
```
[ ] Start application successfully
[ ] Add task with title only
[ ] Add task with title and description
[ ] View empty task list (shows appropriate message)
[ ] View task list with multiple tasks
[ ] Update task title
[ ] Update task description
[ ] Delete task with confirmation
[ ] Cancel task deletion
[ ] Mark task as complete
[ ] Mark task as incomplete (toggle back)
[ ] Enter invalid menu choice (shows error)
[ ] Enter invalid task ID (shows error)
[ ] Enter title >200 chars (rejected)
[ ] Enter empty title (rejected)
[ ] Exit application gracefully
```

**Automated Testing**:
```bash
# Type checking
mypy src/

# Linting
pylint src/ --fail-under=8.0

# Tests with coverage
pytest tests/ --cov=src --cov-report=term-missing

# Ensure all tests pass
pytest tests/ -v
```

### 9.4 Performance Validation

Test performance with the following script:

```python
# performance_test.py
import time
from src.services.task_service import TaskService

service = TaskService()
start = time.time()

# Test 1: Startup (should be <1s)
print(f"Startup time: {time.time() - start:.3f}s")

# Test 2: Create 1000 tasks (should be <10s total, <10ms each)
start = time.time()
for i in range(1000):
    service.create_task(f"Task {i}", f"Description {i}")
print(f"Create 1000 tasks: {time.time() - start:.3f}s")

# Test 3: List tasks (should be <100ms)
start = time.time()
service.list_tasks()
print(f"List 1000 tasks: {time.time() - start:.3f}s")
```

---

## 10. Constraints and Limitations

### 10.1 Phase I Scope Boundaries

**âœ… DO INCLUDE** (In Scope):
- All 5 Basic Level features (Add, View, Update, Delete, Mark Complete)
- In-memory storage using Python data structures
- Interactive CLI menu system
- Input validation and error handling
- Type hints and docstrings
- Unit and integration tests
- Performance optimization for â‰¤1000 tasks

**âŒ DO NOT INCLUDE** (Out of Scope):
- Persistent storage (files, databases) - Phase II
- User authentication or multi-user support - Phase II
- Advanced features (priorities, tags, due dates, reminders) - Phase V
- Recurring tasks - Phase V
- Network features or API endpoints - Phase II
- Web interface - Phase II
- AI chatbot integration - Phase III
- Cloud deployment - Phase IV/V
- Event-driven architecture (Kafka, Dapr) - Phase V

### 10.2 Technical Constraints

**Python Version**: Must use Python 3.13 or higher
- Required for modern type hint syntax
- Performance improvements over 3.12
- Better error messages

**No External Dependencies for Core Logic**:
- Core features must work with standard library only
- Optional: rich/colorama for formatting
- Optional: pytest for testing
- Rationale: Simplicity, portability, learning fundamentals

**In-Memory Storage Only**:
- Tasks stored in Python list in memory
- Data lost when application exits
- No file I/O, no database connections
- Rationale: Phase I focus is on architecture and SDD, not persistence

**Single User**:
- No concept of user accounts
- All tasks belong to single implicit user
- No authentication or authorization
- Rationale: Multi-user support added in Phase II

**Command-Line Interface Only**:
- No graphical user interface
- No web interface
- Terminal-based interaction only
- Rationale: CLI keeps focus on logic, not UI complexity

### 10.3 Performance Boundaries

| Metric | Target | Maximum | Rationale |
|--------|--------|---------|-----------|
| Startup time | <500ms | 1s | Fast launch is essential for CLI tools |
| Operation time | <50ms | 100ms | Interactive feel requires instant response |
| Max tasks supported | 1000+ | 10,000 | In-memory limit, reasonable for Phase I |
| Memory usage | <25MB | 50MB | Should run on any modern system |

If performance degrades:
1. Profile with `cProfile`
2. Identify bottlenecks
3. Refine spec to address issue
4. Regenerate code with optimizations

### 10.4 Hackathon Submission Constraints

**Due Date**: Sunday, December 7, 2025 (11:59 PM)

**Point Value**: 100 points (Phase I only)

**Required Deliverables**:
1. Public GitHub repository
2. Demo video (â‰¤90 seconds)
3. README with setup instructions
4. Working application

**Constraint: No Manual Coding**:
- ALL code must be Claude Code generated from specs
- If found manually coding: specification not detailed enough
- Solution: Refine spec, not code

---

## 11. Governance

### 11.1 Constitution Authority

This constitution is the **governing document** for Phase I development. All implementation decisions, code generation, and quality assessments MUST align with the principles and requirements defined herein.

**Hierarchy**:
1. **Constitution** (this document) - Highest authority
2. Feature specifications (`/specs/phase-1/spec.md`) - Must align with constitution
3. Implementation plans (`/specs/phase-1/plan.md`) - Must follow spec and constitution
4. Generated code - Must satisfy all above

**Conflict Resolution**:
- If spec contradicts constitution â†’ Constitution wins, spec must be revised
- If code contradicts spec â†’ Spec wins, code must be regenerated
- If unsure â†’ Refer to constitution principles, favor simplicity

### 11.2 Claude Code Instructions

When submitting work to Claude Code, **always provide**:

1. **This constitution** (full text or reference)
2. **Feature specification** from `/specs/phase-1/`
3. **Existing codebase context** (relevant files)
4. **Clear request**: "Generate [feature] according to constitution and spec"

**Example Claude Code Prompt**:
```
I'm working on Phase I of the Todo Evolution project. Please generate code
for Feature 1: Add Task.

Context:
- Constitution: .specify/memory/constitution.md (attached)
- Spec: specs/phase-1/spec.md (attached)
- Existing code: src/models/task.py, src/services/task_service.py

Requirements:
- Follow all constitution principles (especially Spec-Driven Development)
- Implement acceptance criteria from spec
- Include type hints and docstrings
- Handle edge cases defined in spec

Generate the following:
1. Update src/services/task_service.py with create_task() method
2. Create tests in tests/test_task_service.py for add task feature
3. Update src/cli/menu.py to add menu option

Ensure code passes mypy and pylint checks.
```

### 11.3 Amendment Process

**Minor Amendments** (Patch version bump: 2.0.0 â†’ 2.0.1):
- Clarifications, typo fixes, formatting improvements
- No change to principles or requirements
- Can be made directly with justification in commit message

**Major Amendments** (Minor version bump: 2.0.0 â†’ 2.1.0):
- Add new principles or sections
- Expand existing requirements materially
- Requires:
  1. Document rationale for change
  2. Update version number
  3. Update "Last Amended" date
  4. Create ADR if architecturally significant
  5. Review and update all dependent templates
  6. Create PHR documenting the amendment

**Breaking Changes** (Major version bump: 2.0.0 â†’ 3.0.0):
- Remove or fundamentally redefine principles
- Backward-incompatible governance changes
- Requires:
  1. All steps from major amendment
  2. Migration plan for existing code
  3. Explicit approval/justification
  4. Impact analysis on all specs and code

### 11.4 Compliance Review

Before ANY feature is considered complete, verify compliance:

**Checklist**:
```
[ ] Feature has written specification (Principle I)
[ ] Code generated by Claude Code, not manually (Principle I)
[ ] Code is simple and readable (Principle II)
[ ] CLI is intuitive with clear prompts (Principle III)
[ ] Inputs validated, errors handled (Principle IV)
[ ] Code is modular and testable (Principle V)
[ ] Follows standard project structure (Principle VI)
[ ] Type hints and docstrings present (Principle VII)
[ ] CLI follows best practices (Principle VIII)
[ ] Performance targets met (Principle IX)
[ ] Documented and committed (Principle X)
```

If ANY item is unchecked â†’ Feature is not done, must be revised.

### 11.5 Deviation Policy

**Deviations from this constitution are NOT allowed without explicit justification.**

If you believe a principle cannot be followed:
1. **Document why** the principle doesn't apply
2. **Propose alternative** approach that achieves same goal
3. **Create ADR** (Architecture Decision Record) explaining decision
4. **Get approval** (from instructor/yourself as architect)
5. **Amend constitution** if deviation should become standard practice

**Example Valid Deviation**:
- Principle: "No external dependencies for core logic"
- Deviation: Need to use `dataclasses` module (stdlib, so allowed)
- Justification: Standard library doesn't count as external dependency
- No ADR needed (already compliant)

**Example Invalid Deviation**:
- Principle: "All code generated by Claude Code"
- Deviation: "I'll manually write this one function, it's faster"
- Justification: INVALID - defeats the purpose of learning spec-driven development
- Solution: Refine spec until Claude Code generates correct code

---

## 12. Appendices

### Appendix A: Spec Template (Quick Reference)

Use this template structure for all feature specs in `/specs/phase-1/`:

```markdown
# Feature Specification: [Feature Name]

**Feature Branch**: `001-add-task`
**Created**: [DATE]
**Status**: Draft â†’ In Progress â†’ Complete

## User Story

As a [user type], I want to [action], so that [benefit].

## Acceptance Criteria

**Given** [initial state]
**When** [action]
**Then** [expected outcome]

## Input/Output Examples

### Example 1: Happy Path
Input: [...]
Output: [...]

### Example 2: Error Case
Input: [...]
Output: [...]

## Edge Cases

- What happens when [scenario]?
- How does system handle [error condition]?

## Validation Rules

- Input X must be [constraint]
- Output Y must include [requirement]

## Implementation Notes

- Use [component] for [purpose]
- Follow [pattern] from constitution
```

### Appendix B: Claude Code Best Practices

**DO**:
âœ… Provide full constitution text or link
âœ… Include complete feature spec
âœ… Show relevant existing code for context
âœ… Be specific about what to generate
âœ… Request type hints and docstrings
âœ… Ask for test coverage
âœ… Specify validation rules explicitly

**DON'T**:
âŒ Write code manually and ask Claude to "fix it"
âŒ Provide vague requirements
âŒ Skip the specification step
âŒ Assume Claude knows your project structure
âŒ Forget to mention constitution requirements
âŒ Generate code without tests

### Appendix C: Testing Checklist (Copy-Paste Ready)

```markdown
## Feature Test Report: [Feature Name]

**Date**: [DATE]
**Tester**: [NAME]
**Status**: [ ] Pass | [ ] Fail

### Automated Tests
- [ ] `mypy src/` â†’ 0 errors
- [ ] `pylint src/` â†’ Score: ___/10 (â‰¥8.0 required)
- [ ] `pytest tests/` â†’ ___/___  tests passed (100% required)
- [ ] `pytest --cov=src` â†’ ___% coverage (â‰¥80% required)

### Manual Acceptance Tests
- [ ] User story scenario 1 works as specified
- [ ] User story scenario 2 works as specified
- [ ] Edge case 1 handled correctly
- [ ] Edge case 2 handled correctly

### Error Handling
- [ ] Invalid input X rejected with helpful message
- [ ] Invalid input Y rejected with helpful message
- [ ] Empty input handled appropriately

### User Experience
- [ ] Prompts are clear and helpful
- [ ] Success messages are displayed
- [ ] Error messages guide user to correct action
- [ ] Output is formatted and readable

### Performance
- [ ] Operation completes in <100ms
- [ ] No noticeable lag or delays
- [ ] Memory usage reasonable

**Notes**: [Any issues or observations]
```

### Appendix D: Commit Message Conventions

Follow these conventions for all Git commits:

**Format**: `<type>: <description>`

**Types**:
- `feat:` New feature (e.g., `feat: add task creation`)
- `fix:` Bug fix (e.g., `fix: validate title length`)
- `docs:` Documentation (e.g., `docs: update README with usage`)
- `test:` Add/update tests (e.g., `test: add task service tests`)
- `refactor:` Code refactor (e.g., `refactor: simplify menu logic`)
- `chore:` Maintenance (e.g., `chore: configure linting`)
- `spec:` Specification changes (e.g., `spec: add task update acceptance criteria`)

**Examples**:
```bash
feat: add task creation with validation
feat: implement task list display with table formatting
fix: reject empty task titles with clear error message
test: add integration tests for CLI menu
docs: add installation instructions to README
spec: define acceptance criteria for delete task feature
```

### Appendix E: Quick Start Commands

**Project Setup**:
```bash
# Create project with UV
uv init todo-phase-1
cd todo-phase-1

# Install dependencies
uv add pytest mypy pylint

# Install optional formatting
uv add rich  # or: uv add colorama
```

**Development Commands**:
```bash
# Run application
uv run python src/main.py

# Type checking
uv run mypy src/

# Linting
uv run pylint src/

# Run tests
uv run pytest tests/

# Run tests with coverage
uv run pytest tests/ --cov=src --cov-report=term-missing

# Run specific test
uv run pytest tests/test_task_service.py::test_create_task
```

**Quality Check Script** (save as `check.sh`):
```bash
#!/bin/bash
echo "ğŸ” Running quality checks..."

echo "\n1ï¸âƒ£ Type checking..."
uv run mypy src/ || exit 1

echo "\n2ï¸âƒ£ Linting..."
uv run pylint src/ --fail-under=8.0 || exit 1

echo "\n3ï¸âƒ£ Tests..."
uv run pytest tests/ || exit 1

echo "\n4ï¸âƒ£ Coverage..."
uv run pytest tests/ --cov=src --cov-report=term-missing --cov-fail-under=80 || exit 1

echo "\nâœ… All quality checks passed!"
```

---

## Summary

This constitution establishes the **foundation** for Phase I of the Todo Evolution project. By following these principles, specifications, and workflows, you will:

1. **Master Spec-Driven Development** - Learn to architect with words, not code
2. **Build Quality Software** - Create clean, testable, maintainable code
3. **Prepare for Evolution** - Establish patterns that scale through all 5 phases
4. **Deliver on Time** - Clear requirements and process lead to predictable outcomes

**Remember the Golden Rule**: When in doubt, favor **simplicity** and adherence to **core principles** over cleverness or shortcuts.

**Next Steps**:
1. Create feature specification in `/specs/phase-1/spec.md`
2. Submit to Claude Code with this constitution
3. Generate implementation
4. Test against acceptance criteria
5. Iterate on spec if needed
6. Deliver on December 7, 2025

---

**Version**: 2.0.0 | **Ratified**: 2025-12-25 | **Last Amended**: 2025-12-25

*This constitution governs Phase I exclusively. Phase II will introduce a new constitution with expanded principles for full-stack development, user authentication, and persistent storage.*
